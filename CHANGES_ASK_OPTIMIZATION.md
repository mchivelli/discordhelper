# /ask Command â€” Tiered Retrieval Optimization

## What Changed

### New File: `src/commands/ask.js`
The `/ask` command lets users ask natural-language questions about chat history.

**Subcommands:**
- `/ask channel question:"..." [channel:#general] [hours:24] [messages:100]`
- `/ask server question:"..." [hours:24] [messages:100]` (requires Manage Messages)

**Parameters:**
- `question` (required) â€” what you want to know
- `channel` â€” which channel to search (defaults to current)
- `hours` â€” how far back to look (1-168, default 24)
- `messages` â€” OR specify exact message count (10-1000)
- Cannot use both `hours` and `messages`

### Modified: `src/utils/ai.js`

**New constants:**
- `ASK_TOKEN_BUDGET` (env: `ASK_TOKEN_BUDGET`, default: 8000)
- `ASK_MAX_RESPONSE_TOKENS` (env: `ASK_MAX_RESPONSE_TOKENS`, default: 1000)
- `ASK_MODEL` (env: `ASK_MODEL`, default: same as SUMMARIZATION_MODEL)

**New functions:**

| Function | Purpose |
|----------|---------|
| `extractKeywords(question)` | Strips stop words from question, returns meaningful search terms |
| `getSummariesForTimeRange(db, guildId, channelId, hours)` | Queries `chat_summaries` table for existing daily summaries covering the time range |
| `getMessageCoverage(db, guildId, channelId, hours)` | Counts hourly buckets with stored messages, returns coverage % |
| `getKeywordMatchedMessages(db, guildId, channelId, hours, keywords, limit)` | SQL `LIKE` search for messages matching question keywords |

**Rewritten function: `answerQuestionWithContext()`**

Now uses a 3-tier strategy instead of always sending all raw messages to the LLM:

```
Tier 1: Check chat_summaries table for existing daily summaries
Tier 2: Extract keywords from question, fetch only matching raw messages
Tier 3: Fall back to full raw transcript (original behavior)
```

**Strategy selection logic:**

| Condition | Strategy | What the LLM sees |
|-----------|----------|-------------------|
| Summaries exist + keyword hits found | `hybrid` | Summaries + targeted raw messages |
| Summaries exist + no keyword hits | `summary-only` | Just the summaries |
| No summaries available | `raw` | Full raw message transcript |

**Why this matters:**
- `hybrid` saves tokens by sending summaries + only relevant messages instead of ALL messages
- `summary-only` avoids re-analyzing hundreds of messages when a summary already answers the question
- `raw` preserves original behavior as fallback â€” nothing breaks

### Modified: `src/utils/file-db.js`

- Added `content LIKE ?` support to the `chat_messages` query handler (enables keyword search)
- Resolved pre-existing merge conflict markers throughout the file
- Restored `where task_id =` handler in status UPDATE (was accidentally removed)

---

## What /ask Does NOT Do

**It does NOT fetch messages the bot didn't log.**

The `/ask` command uses `getRecentMessages()` which ONLY queries the database. If the bot was offline and missed messages, those messages won't be in the database and won't be analyzed.

**Workaround:** Run `/summarize fetch_history channel:#your-channel days:7` first to backfill messages from Discord's API (up to 14 days). After that, `/ask` can analyze them.

**The `/analyse` command is different** â€” it uses `getChannelMessages()` which has a Discord API fallback that fetches up to 500 messages live if the database is empty.

### Coverage Indicator

The response embed now shows data coverage:
- **Footer:** Shows `X% coverage` â€” what fraction of hourly time buckets have stored messages
- **Warning field:** If coverage < 80%, a yellow warning appears: "Answer may be incomplete"

This tells users when the bot's data has gaps.

---

## Environment Variables

| Variable | Default | Purpose |
|----------|---------|---------|
| `ASK_TOKEN_BUDGET` | 8000 | Max input tokens for /ask context |
| `ASK_MAX_RESPONSE_TOKENS` | 1000 | Max output tokens for AI response |
| `ASK_MODEL` | Same as `SUMMARIZATION_MODEL` | Which model to use for /ask |

---

## Testing Guide

### Prerequisites
1. Bot is running and connected to Discord
2. Bot has been logging messages (check `DAILY_SUMMARY_SOURCE_CHANNELS` in `.env`)
3. At least one daily summary exists in `chat_summaries` (generated by the daily cron or `/summarize`)

### Test 1: Basic /ask (raw strategy)
**Setup:** Use a channel with logged messages but NO existing summaries.
```
/ask channel question:"What was discussed today?" hours:6
```
**Expected:**
- Strategy shown: "Raw Messages"
- Answer based on actual chat content
- Coverage % shown in footer

### Test 2: Summary-aware /ask (hybrid or summary-only)
**Setup:** First generate a summary, then ask about it.
```
/summarize channel channel:#general hours:24
/ask channel question:"What was discussed?" channel:#general hours:24
```
**Expected:**
- Strategy shown: "Summaries + Targeted Messages" or "Existing Summaries"
- Answer should reference content from the summary
- Faster response, fewer tokens used

### Test 3: Keyword targeting (hybrid strategy)
**Setup:** Use a channel where a specific topic was discussed and summaries exist.
```
/ask channel question:"Did anyone mention deployment?" channel:#dev hours:48
```
**Expected:**
- Strategy: "Summaries + Targeted Messages"
- AI sees the summary PLUS only messages containing "deployment"
- Check logs: `[ASK] Keyword search for [deployment] returned X messages`

### Test 4: Coverage warning
**Setup:** Ask about a time range where the bot was partially offline.
```
/ask channel question:"What happened this week?" hours:168
```
**Expected:**
- If bot was offline for some hours, coverage will be < 100%
- If < 80%, yellow warning field appears in embed
- Footer shows actual coverage %

### Test 5: Server-wide ask
**Setup:** Requires Manage Messages permission.
```
/ask server question:"What are people working on?" hours:24
```
**Expected:**
- Searches across all channels
- Same tiered strategy applies

### Test 6: No messages found
```
/ask channel question:"anything" channel:#empty-channel hours:1
```
**Expected:**
- "No messages found" with suggestions to try longer period or fetch history

### Test 7: Backfilling missed messages
**Setup:** A channel where bot was offline.
```
/summarize fetch_history channel:#general days:3
/ask channel question:"What happened 2 days ago?" channel:#general hours:72
```
**Expected:**
- fetch_history pulls messages from Discord API and stores them
- /ask can now find and analyze those backfilled messages

### Checking Logs
Look for these log lines to verify the strategy is working:
```
[ASK] Found X existing summary/summaries covering the time range
[ASK] Keyword search for [keyword1, keyword2] returned X messages
[ASK] Strategy: hybrid | X raw msgs, Y tokens for: "question..."
```

### What to Watch For
- **Token savings:** Compare `~X tokens` in footer between raw vs hybrid strategies
- **Speed:** Hybrid/summary-only should respond faster (less context for LLM to process)
- **Accuracy:** Answers should still be specific and attribute to correct usernames

---

## Backfill Dedup & Consistency Improvements

### Problem
Running `/summarize fetch_history` multiple times on the same channel would:
- Re-write every message to disk even if already stored (wasted I/O)
- Report misleading stats ("Stored 500" when 400 were already there)
- `fetchMessagesFromDiscord()` used `message.author.username` while `storeChatMessage()` used `message.author.tag` â€” inconsistent records

### Changes

**`src/utils/ai.js`:**

- **New: `chatMessageExists(db, compositeId)`** â€” O(1) check using direct file/cache lookup (doesn't load entire table)
- **`storeChatMessage()` now dedup-aware:**
  - Checks if message already exists before writing
  - Returns `{ stored: true, existed: false }` for new messages
  - Returns `{ stored: false, existed: true }` for duplicates (no disk write)
  - Username field now uses `message.author.tag || message.author.username` for consistency
- **`fetchMessagesFromDiscord()` fixed:**
  - Uses `storeChatMessage()` dedup (no redundant writes)
  - Skips bot messages from storage (matches live handler behavior)
  - In-memory results now include `user_id`, `attachments` fields matching DB schema
  - Username uses `.tag || .username` consistently

**`src/commands/summarize.js` â€” `handleFetchHistory()`:**

- Tracks **4 separate counters**: processed, newly stored, already existed, bot messages
- Shows accurate breakdown in response embed:
  - ðŸ’¾ Newly Stored â€” actually new messages written to DB
  - ðŸ“‚ Already Existed â€” skipped because already in DB
  - ðŸ¤– Bot Messages â€” skipped by design
- **Progress updates** every ~500 messages during long fetches
- Embed color: green if new data added, yellow if everything already existed
- Footer tells user what commands are available next

### Data Structure Consistency

All message sources now produce identical field structures:

| Field | Live handler (`index.js`) | Backfill (`fetch_history`) | Analyse fallback (`fetchMessagesFromDiscord`) |
|-------|--------------------------|---------------------------|----------------------------------------------|
| `id` | `guildId_channelId_msgId` | Same | Same |
| `username` | `.tag \|\| .username` | `.tag \|\| .username` | `.tag \|\| .username` |
| `user_id` | `author.id` | `author.id` | `author.id` |
| `content` | `content \|\| ''` | `content \|\| ''` | `content \|\| ''` |
| `attachments` | JSON or null | JSON or null | JSON or null |
| Bot filtered | Yes | Yes | Yes |
| Dedup | Yes | Yes | Yes |
